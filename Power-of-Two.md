Power of Two
=======

1.问题描述
------

Given an integer, write a function to determine if it is a power of two. <br>
给定一个整数，判断它是不是2的幂。<br>

2.思路
----

如果一个数是2的幂，那么它不断地除以2，并且在部位零的情况下，最终会得到1，可以根据这个条件判断给定的整数是不是2的幂。<br>

3.代码I
-----

```c
bool isPowerOfTwo(int n) {
    while (n>1) {
        if (n%2==0) {//因为有可能给的整数不能被2整除，那它一定不是2的幂，就自然而然地被排除了
        n=n/2;
        }
        else break;
    }
    if (n==1) return true;
    else return false;
}
```
4.代码II
----

```c
bool isPowerOfTwo(int n) {
return (n>0) &&!(n&(n-1));
}
```

4.总结
-----

n&(n-1)作用：
-----------

将n的二进制表示中的最低位为1的改为0，先看一个简单的例子：<br>
n = 10100(二进制），则(n-1) = 10011 ==》n&(n-1) = 10000<br>
可以看到原本最低位为1的那位变为0。<br>
n&(n-1)的应用
-----

1、 判断一个数是否是2的方幂<br>
n > 0 && ((n & (n - 1)) == 0 )<br>
解释((n & (n-1)) == 0)：<br>
如果A&B==0，表示A与B的二进制形式没有在同一个位置都为1的时候。<br>
不妨先看下n-1是什么意思。<br>
   令:n=1101011000(二进制,十进制也一样)，则<br>
    n-1=1101010111。<br>
n&(n-1)=1101010000<br>
由此可以得出，n和n-1的低位不一样，直到有个转折点，就是借位的那个点，从这个点开始的高位，n和n-1都一样，如果高位一样这就造成一个问题，就是n和n-1在相同的位上可能会有同一个1，从而使((n & (n-1)) != 0),如果想要
((n & (n-1)) == 0)，则高位必须全为0，这样就没有相同的1。<br>
所以n是2的幂或0<br>
2. 求某一个数的二进制表示中1的个数<br>
```c
while (n >0 ) {
      count ++;
      n &= (n-1);
}
```

3. 计算N!的质因数2的个数。<br>
容易得出N!质因数2的个数 = [N / 2] + [N / 4] + [N / 8] + ....<br>
下面通过一个简单的例子来推导一下过程：N = 10101(二进制表示）<br>
现在我们跟踪最高位的1，不考虑其他位假定为0，<br>
则在<br>
[N / 2]    01000<br>
[N / 4]    00100<br>
[N / 8]    00010<br>
[N / 8]    00001<br>
则所有相加等于01111 = 10000 - 1<br>
由此推及其他位可得：(10101)!的质因数2的个数为10000 - 1 + 00100 - 1 + 00001 - 1 = 10101 - 3(二进制表示中1的个数)<br>

推及一般N!的质因数2的个数为N-(N二进制表示中1的个数)<br>
